#!/usr/bin/env bash
set -euo pipefail

# Remember current directory
CUR_DIR=$(pwd)
# Change to repository directory (ensure REP_DIR is set or use current)
cd "${REP_DIR:-$CUR_DIR}" || exit 1

# Fetch all tags from origin to ensure we see the latest version
git fetch --tags origin

# Determine the last version tag from remote, defaulting to v0.0.0 if none
LAST_TAG=$(git describe --tags --abbrev=0 origin/master 2>/dev/null || echo "v0.0.0")

# If `.giti_tag` exists, use its last line instead (to preserve local history), but ensure it's not behind
if [[ -f .giti_tag ]]; then
  LOCAL_TAG=$(tail -n1 .giti_tag)
  # Compare semantic version order: choose whichever is greater
  if [[ "$(printf "%s\n%s" "$LOCAL_TAG" "$LAST_TAG" | sort -V | tail -n1)" == "$LOCAL_TAG" ]]; then
    LAST_TAG="$LOCAL_TAG"
  fi
fi

# Strip leading 'v' and split into components
VER=${LAST_TAG#v}
IFS='.' read -r MAJOR MINOR PATCH <<< "$VER"

# Increment patch version
PATCH=$((PATCH + 1))
NEW_TAG="v${MAJOR}.${MINOR}.${PATCH}"

# Record new tag into .giti_tag
echo "$NEW_TAG" > .giti_tag

# Prepare prefix for commit message
PREFIX="[$NEW_TAG]"

# Clean cached files (optional)
git rm -r --cached .

# Show diff
echo
git diff

# Read commit message from user
# shellcheck disable=SC2162
read -p "Commit Message: " MSG

# Prefix the commit message
COMMIT_MSG="$PREFIX $MSG"

# Stage all changes
git add .

# Na raiz do reposit√≥rio local
gh release create "$NEW_TAG" \
  --title "$COMMIT_MSG"

# Create and push the new tag
git tag "$NEW_TAG"
git commit -m "$COMMIT_MSG"
git push origin master "$NEW_TAG"

# Return to original directory
cd "$CUR_DIR" || exit 1